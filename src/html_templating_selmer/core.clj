(ns html-templating-selmer.core
  (:require [selmer.parser :as selmer]
            [selmer.filters :as filters]
            [selmer.middleware :refer [wrap-error-page]]))

(defn foo
  "I don't do a whole lot."
  [x]
  (println x "Hello, World!"))

(selmer.parser/cache-off!)

(selmer/render "Hello, {{name}}" {:name "World!"})

(selmer/render-file "hello.html" {:name "World"})

(selmer/render-file "hello.html" {:items (range 10)})

(filters/add-filter! :empty? empty?)

(def files ["file 1"])

(selmer/render "{% if files|empty? %}no files{% else %}{{files}}{% endif %}" {:files files})

;; Content is escaped by default
; To override this (if its not that's safe and generated by the server)

(filters/add-filter! :foo
                     (fn [x] [:safe (.toUpperCase x)]))
(selmer/render "{{x|foo}}" {:x "<div>I'm safe</div>"})

; Custom tags
(selmer/add-tag!
  :image
  (fn [args context-map]
    (str "<img src=" (first args) "/>")))
(selmer/render "{% image \"http://foo.com/logo.jpg\" %}" {})

(selmer/add-tag!
  :uppercase
  (fn [args context-map block]
    (.toUpperCase (get-in block [:uppercase :content])))
  :enduppercase)
(selmer/render
  "{% uppercase %}foo {{bar}} baz{% enduppercase %}"
  {:bar "injected"})


; Inheriting templates using Extends and Include

;; Renderer and error handling
(defn renderer []
  (wrap-error-page
    (fn [template]
      {:status 200
       :body (selmer/render-file template {})})))

((renderer) "hello.html")                                   ;No compilation errors
((renderer) "error.html")                                   ;Some compilation error